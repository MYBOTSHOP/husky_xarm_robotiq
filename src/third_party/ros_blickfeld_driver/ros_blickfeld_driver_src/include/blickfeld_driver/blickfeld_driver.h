/**
 * @file
 * @copyright Copyright (C) 2020, Blickfeld GmbH
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Header for class BlickfeldDriver
 */

#pragma once

#include <memory>

/// ROS
/// diagnostic_updater.h has an extra ';'
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
#include <diagnostic_updater/diagnostic_updater.h>
#pragma GCC diagnostic pop
#include <ros/ros.h>
#include <ros/service_server.h>
#include <std_srvs/Empty.h>
#include <tf2_ros/static_transform_broadcaster.h>

#include <blickfeld_driver/ImuStaticTransformation.h>
#include <blickfeld_driver/SetScanPattern.h>
#include <blickfeld_driver_core/blickfeld_driver_core.h>

namespace blickfeld {
namespace ros_interop {

/**
 * @class blickfeld::ros_interop::BlickfeldDriver
 * @brief Main class for the node to handle the ROS interfacing
 */
class BlickfeldDriver : public BlickfeldDriverCore {
 public:
  /**
   * @brief Constructor
   * @param[in] node_handle
   * @param[in] private_node_handle the private ros::NodeHandle (used to publish messages and to advertise services)
   */
  BlickfeldDriver(ros::NodeHandle node_handle, ros::NodeHandle private_node_handle);

  /**
   * @brief Desctructor
   *
   */
  ~BlickfeldDriver() override;

  /**
   * @brief Reads ROS params, sets up the publishers, and starts the core thread
   * @return true on success
   */
  bool init();

  /**
   * @brief publishPointCloud publishes a point cloud 2 message
   *
   * @param[in] point_cloud PointCloud2Ptr
   * @param[in] device_time device time
   */
  void publishPointCloud(PointCloud2Ptr& point_cloud, time_t device_time) override;

  /**
   * @brief publishStatus publishes a diagnostic status message
   *
   * @param[in] status DiagnosticStatusPtr
   */
  void publishStatus(DiagnosticStatusPtr& status) override;

  /**
   * @brief publishRangeImage publishes a sensor image message based on points range
   *
   * @param[in] range_image
   * @param[in] device_time device time
   */
  void publishRangeImage(SensorMsgImagePtr& range_image, time_t device_time) override;

  /**
   * @brief publishIntensityImage publishes a sensor image message based on points intensity
   *
   * @param[in] intensity_image
   * @param[in] device_time device time
   */
  void publishIntensityImage(SensorMsgImagePtr& intensity_image, time_t device_time) override;

  /**
   * @brief publishAmbientImage publishes a sensor image message based on points ambient
   *
   * @param[in] ambient_image
   * @param[in] device_time device time
   */
  void publishAmbientImage(SensorMsgImagePtr& ambient_image, time_t device_time) override;

  /**
   * @brief publishPointIdImage publishes a sensor image message which contains point ids
   *
   * @param[in] point_id_image
   * @param[in] device_time device time
   */
  void publishPointIdImage(SensorMsgImagePtr& point_id_image, time_t device_time) override;

  /**
   * @brief publishImu publishes a sensor imu message
   *
   * @param[in] imu
   * @param[in] device_time
   */
  void publishImu(SensorMsgImuPtr& imu, time_t device_time) override;

  /**
   * @brief publishImuStaticTF publishes imu acceleration as static tf transform
   *
   * @param[in] transform_msg_stamped
   */
  void publishImuStaticTF(const TransformMsgStamped& transform_msg_stamped) override;

  /**
   * @brief printLogMessages prints log messages that were collected during different stages of processing
   *
   * @param[in] log_messages std::unordered_map<LogLevel, std::ostringstream>;
   */
  void printLogMessages(const LogMessages& log_messages) override;

 private:
  /**
   * @brief setScanPatternCallback is a service callback for setting the scan pattern on the device
   * @param[in] service_request
   * @param[out] service_response
   * @return true on success
   */
  bool setScanPatternCallback(blickfeld_driver::SetScanPatternRequest& service_request,
                              blickfeld_driver::SetScanPatternResponse& service_response);

  /**
   * @brief publishImuStaticTFCallback is a service callback for publishing static tf generated by Imu accelration
   * @param[in] service_request
   * @param[out] service_response
   * @return true on success
   */
  bool publishImuStaticTFCallback(blickfeld_driver::ImuStaticTransformationRequest& service_request,
                                  blickfeld_driver::ImuStaticTransformationResponse& service_response);

  /**
   * @brief createPointCloudOptions reads and verifies the ROS parameters and create point_cloud_options
   *
   * @return PointCloudOptions, point cloud options such as publishing options
   */
  PointCloudOptions createPointCloudOptions();

  /**
   * @brief createImageOptions reads and verifies the ROS parameters and create image options
   *
   * @return createImageOptions created image options
   */
  ImageOptions createImageOptions();

  /**
   * @brief createDeviceAlgorithmOptions reads and verifies the ROS parameters and create device_algorithm_options
   *
   * @return DeviceAlgorithmOptions, the options for on device algorithm
   */
  DeviceAlgorithmOptions createDeviceAlgorithmOptions();

  /**
   * @brief createImuOptions reads and verifies the ROS parameters and creates imu options
   *
   * @return ImuOptions created imu options
   */
  ImuOptions createImuOptions();

  /// The ROS node handle and private node handle
  ros::NodeHandle node_handle_;
  ros::NodeHandle private_node_handle_;

  ros::Publisher ambient_image_publisher_;
  ros::Publisher diagnostics_publisher_;
  ros::Publisher imu_publisher_;
  ros::Publisher intensity_image_publisher_;
  ros::Publisher point_cloud_publisher_;
  ros::Publisher range_image_publisher_;
  ros::Publisher point_id_image_publisher_;

  ros::ServiceServer scan_pattern_service_;

  ros::ServiceServer imu_static_tf_service_;
  tf2_ros::StaticTransformBroadcaster static_broadcaster_;

  bool use_lidar_timestamp_ = false;
};

}  // namespace ros_interop
}  // namespace blickfeld
